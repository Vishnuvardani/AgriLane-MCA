<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Route Planning - AgriLane</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://unpkg.com/leaflet-routing-machine@3.2.12/dist/leaflet-routing-machine.js"></script>
    <link rel="stylesheet" href="https://unpkg.com/leaflet-routing-machine@3.2.12/dist/leaflet-routing-machine.css" />

    <style>
:root {
  --primary: #577656;
  --secondary: #76A37E;
  --accent: #2E4C3A;
  --light: #E6F0E6;
  --white: #ffffff;
  --dark: #1a1a1a;
  --shadow: rgba(87, 118, 86, 0.1);
  --gradient: linear-gradient(135deg, var(--primary), var(--secondary));
}

* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  font-family: 'Inter', sans-serif;
  background: var(--light);
  color: var(--dark);
  line-height: 1.6;
}

.container {
  max-width: 1200px;
  margin: 0 auto;
  padding: 0 20px;
}

.btn {
  padding: 12px 24px;
  border: none;
  border-radius: 8px;
  cursor: pointer;
  font-weight: 500;
  transition: all 0.3s ease;
  text-decoration: none;
  display: inline-block;
}

.btn-primary {
  background: var(--gradient);
  color: var(--white);
}

.btn-primary:hover {
  transform: translateY(-2px);
  box-shadow: 0 8px 25px var(--shadow);
}

.card {
  background: var(--white);
  border-radius: 12px;
  padding: 24px;
  box-shadow: 0 4px 20px var(--shadow);
  transition: transform 0.3s ease;
}

.sidebar {
  position: fixed;
  left: 0;
  top: 0;
  width: 250px;
  height: 100vh;
  background: var(--white);
  box-shadow: 2px 0 10px var(--shadow);
  padding: 80px 0 20px;
  z-index: 90;
}

.sidebar-nav {
  list-style: none;
}

.sidebar-nav li {
  margin: 8px 0;
}

.sidebar-nav a {
  display: flex;
  align-items: center;
  padding: 12px 24px;
  color: var(--dark);
  text-decoration: none;
  transition: all 0.3s ease;
}

.sidebar-nav a:hover {
  background: var(--light);
  color: var(--primary);
}

.main-content {
  margin-left: 250px;
  padding: 24px;
  min-height: 100vh;
}

.page-header {
  margin-bottom: 32px;
}

.header-title-row {
  display: flex;
  justify-content: space-between;
  align-items: center;
  flex-wrap: wrap;
  gap: 16px;
}

.header-title-row h1 {
  margin: 0;
  color: var(--primary);
  font-size: 28px;
  font-weight: 600;
}

.form-group {
  margin-bottom: 20px;
}

.form-label {
  display: block;
  margin-bottom: 8px;
  font-weight: 500;
  color: var(--accent);
}

.form-input {
  width: 100%;
  padding: 12px 16px;
  border: 2px solid var(--light);
  border-radius: 8px;
  font-size: 16px;
  transition: border-color 0.3s ease;
}

.form-input:focus {
  outline: none;
  border-color: var(--primary);
}

.route-planning-container {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 24px;
}

.route-inputs {
  grid-column: span 1;
}

.route-map {
  grid-column: span 1;
}

.route-options {
  grid-column: span 2;
}

.route-export {
  grid-column: span 2;
}

.map-container {
  height: 400px;
  background: var(--light);
  border-radius: 8px;
  margin-top: 16px;
}

#map {
  height: 100%;
  width: 100%;
  border-radius: 8px;
}

.route-option {
  border: 2px solid var(--light);
  border-radius: 8px;
  padding: 16px;
  margin-bottom: 16px;
  transition: all 0.3s ease;
}

.route-option:hover {
  border-color: var(--primary);
  background: var(--light);
}

.route-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 12px;
}

.route-header h4 {
  color: var(--primary);
  margin: 0;
}

.route-distance {
  background: var(--secondary);
  color: var(--white);
  padding: 4px 12px;
  border-radius: 20px;
  font-size: 14px;
  font-weight: 600;
}

.export-options {
  display: flex;
  gap: 16px;
  flex-wrap: wrap;
}

.empty-state {
  text-align: center;
  padding: 40px 20px;
  color: var(--accent);
  font-style: italic;
  background: var(--light);
  border-radius: 8px;
  margin: 20px 0;
}

@media (max-width: 768px) {
  .sidebar {
    transform: translateX(-100%);
    transition: transform 0.3s ease;
  }
  
  .main-content {
    margin-left: 0;
  }
  
  .route-planning-container {
    grid-template-columns: 1fr;
  }
  
  .route-inputs,
  .route-map,
  .route-options,
  .route-export {
    grid-column: span 1;
  }
  
  .export-options {
    flex-direction: column;
  }
}
    </style>
</head>
<body>
    <div id="sidebar" class="sidebar">
        <ul class="sidebar-nav">
            <li><a href="dashboard.html">üìä Dashboard</a></li>
            <li><a href="farms.html">üåæ Farms</a></li>
            <li><a href="transporters.html">üöõ Transporters</a></li>
            <li><a href="marketplace.html">üõí Marketplace</a></li>
            <li><a href="routes.html">üó∫Ô∏è Routes</a></li>

            <li><a href="deliveries.html">üì¶ Deliveries</a></li>
            <li><a href="reports.html">üìà Reports</a></li>
            <li><a href="settings.html">‚öôÔ∏è Settings</a></li>
            <li><a href="#" onclick="logout()">üö™ Logout</a></li>
        </ul>
    </div>

    <div class="main-content">
        <header class="page-header">
            <div class="header-title-row">
                <h1>Route Planning & Optimization</h1>
                <button class="btn btn-primary" onclick="generateOptimalRoute()">Generate Route</button>
            </div>
        </header>

        <div class="route-planning-container">
            <div class="route-inputs card">
                <h3>Route Configuration</h3>
                <div class="form-group">
                    <label class="form-label">Starting Farm</label>
                    <select id="startingFarm" class="form-input">
                        <option value="">Select Farm</option>
                    </select>
                </div>
                <div class="form-group">
                    <label class="form-label">Delivery Locations</label>
                    <textarea id="deliveryLocations" class="form-input" rows="4"></textarea>
                </div>
                <div class="form-group">
                    <label class="form-label">Vehicle Type</label>
                    <select id="vehicleType" class="form-input">
                        <option value="truck">Truck (5 ton)</option>
                        <option value="van">Van (2 ton)</option>
                        <option value="pickup">Pickup (1 ton)</option>
                    </select>
                </div>
                <button class="btn btn-primary" onclick="calculateRoute()">Calculate Optimal Route</button>
            </div>

            <div class="route-map card">
                <h3>Route Visualization</h3>
                <div id="map" class="map-container" style="height: 400px; width: 100%;"></div>
            </div>

            <div class="route-options card">
                <h3>Route Options</h3>
                <div id="routeOptionsList">
                    <div class="empty-state">
                        <p>No routes calculated yet. Configure route settings and click "Calculate Optimal Route" to generate options.</p>
                    </div>
                </div>
            </div>

            <div class="route-export card">
                <h3>Export Route Details</h3>
                <div class="export-options">
                    <button class="btn" onclick="exportToPDF()">üìÑ Export to PDF</button>
                    <button class="btn" onclick="shareRoute()">üì§ Share Route</button>
                </div>
            </div>
        </div>
    </div>

    <script>
// Authentication & Role Management
function isAuthenticated() {
    return sessionStorage.getItem('user') !== null;
}

function getCurrentUser() {
    const user = sessionStorage.getItem('user');
    return user ? JSON.parse(user) : null;
}

function requireAuth() {
    if (!isAuthenticated()) {
        window.location.href = 'login.html';
        return false;
    }
    return true;
}

function generateNavigation() {
    const user = getCurrentUser();
    if (!user) return '';
    
    const baseNav = [
        { href: 'dashboard.html', icon: 'üìä', text: 'Dashboard' },
        { href: 'farms.html', icon: 'üåæ', text: 'Farms' },
        { href: 'transporters.html', icon: 'üöõ', text: 'Transporters' },
        { href: 'marketplace.html', icon: 'üõí', text: 'Marketplace' },
        { href: 'routes.html', icon: 'üó∫Ô∏è', text: 'Routes' },

        { href: 'deliveries.html', icon: 'üì¶', text: 'Deliveries' }
    ];
    
    if (user.role === 'admin') {
        baseNav.push({ href: 'reports.html', icon: 'üìà', text: 'Reports' });
    }
    
    baseNav.push(
        { href: 'settings.html', icon: '‚öôÔ∏è', text: 'Settings' },
        { href: '#', icon: 'üö™', text: 'Logout', onclick: 'logout()' }
    );
    
    return baseNav.map(item => 
        `<li><a href="${item.href}"${item.onclick ? ` onclick="${item.onclick}"` : ''}>${item.icon} ${item.text}</a></li>`
    ).join('');
}

function logout() {
    sessionStorage.removeItem('user');
    window.location.href = 'login.html';
}

// AgriLane Mapping Utility
class AgriLaneMap {
    constructor(containerId, options = {}) {
        this.containerId = containerId;
        this.map = null;
        this.markers = [];
        this.routingControl = null;
        this.options = {
            center: [20.5937, 78.9629],
            zoom: 6,
            ...options
        };
        this.init();
    }
    
    init() {
        this.map = L.map(this.containerId).setView(this.options.center, this.options.zoom);
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '¬© OpenStreetMap contributors',
            maxZoom: 19
        }).addTo(this.map);
    }
    
    addMarker(lat, lng, options = {}) {
        const marker = L.marker([lat, lng], options).addTo(this.map);
        this.markers.push(marker);
        if (options.popup) {
            marker.bindPopup(options.popup);
        }
        return marker;
    }
    
    createRoute(waypoints, options = {}) {
        if (this.routingControl) {
            this.map.removeControl(this.routingControl);
        }
        
        const routeWaypoints = waypoints.map(wp => L.latLng(wp.lat, wp.lng));
        
        this.routingControl = L.Routing.control({
            waypoints: routeWaypoints,
            routeWhileDragging: false,
            addWaypoints: false,
            createMarker: (i, waypoint, n) => {
                const marker = L.marker(waypoint.latLng);
                if (options.popups && options.popups[i]) {
                    marker.bindPopup(options.popups[i]);
                }
                return marker;
            },
            lineOptions: {
                styles: [{ color: '#577656', weight: 4, opacity: 0.7 }]
            }
        }).addTo(this.map);
        
        return this.routingControl;
    }
    
    // Calculate route using OpenRouteService API
    async calculateRoute(start, end, profile = 'driving-car') {
        try {
            const startCoords = typeof start === 'string' ? this.getCityCoords(start) : start;
            const endCoords = typeof end === 'string' ? this.getCityCoords(end) : end;
            
            // Use OpenRouteService API for real route calculation
            const apiKey = '5b3ce3597851110001cf6248a1b2212c3c5c4b5bb4e8c8b8f8f8f8f8'; // Demo key
            const url = `https://api.openrouteservice.org/v2/directions/${profile}`;
            
            const response = await fetch(url, {
                method: 'POST',
                headers: {
                    'Authorization': apiKey,
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    coordinates: [[startCoords.lng, startCoords.lat], [endCoords.lng, endCoords.lat]],
                    format: 'json'
                })
            });
            
            if (response.ok) {
                const data = await response.json();
                const route = data.routes[0];
                
                return {
                    distance: Math.round(route.summary.distance / 1000),
                    duration: Math.round(route.summary.duration / 60),
                    coordinates: route.geometry.coordinates.map(coord => ({ lat: coord[1], lng: coord[0] }))
                };
            } else {
                return {
                    distance: this.calculateDistance(startCoords, endCoords),
                    duration: this.estimateDuration(startCoords, endCoords),
                    coordinates: [startCoords, endCoords]
                };
            }
        } catch (error) {
            const startCoords = typeof start === 'string' ? this.getCityCoords(start) : start;
            const endCoords = typeof end === 'string' ? this.getCityCoords(end) : end;
            
            return {
                distance: this.calculateDistance(startCoords, endCoords),
                duration: this.estimateDuration(startCoords, endCoords),
                coordinates: [startCoords, endCoords]
            };
        }
    }
    
    estimateDuration(point1, point2) {
        const distance = this.calculateDistance(point1, point2);
        return Math.round(distance * 1.5);
    }
    
    getCityCoords(cityName) {
        const cityCoords = {
            'mumbai': { lat: 19.0760, lng: 72.8777 },
            'delhi': { lat: 28.6139, lng: 77.2090 },
            'bangalore': { lat: 12.9716, lng: 77.5946 },
            'pune': { lat: 18.5204, lng: 73.8567 },
            'chennai': { lat: 13.0827, lng: 80.2707 },
            'kolkata': { lat: 22.5726, lng: 88.3639 },
            'hyderabad': { lat: 17.3850, lng: 78.4867 }
        };
        const city = cityName.toLowerCase();
        return cityCoords[city] || { lat: 20.5937, lng: 78.9629 };
    }
    
    calculateDistance(point1, point2) {
        const R = 6371;
        const dLat = this.toRad(point2.lat - point1.lat);
        const dLon = this.toRad(point2.lng - point1.lng);
        
        const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                Math.cos(this.toRad(point1.lat)) * Math.cos(this.toRad(point2.lat)) *
                Math.sin(dLon/2) * Math.sin(dLon/2);
        
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
        return Math.round(R * c);
    }
    
    toRad(degrees) {
        return degrees * (Math.PI / 180);
    }
}

// Authentication check
requireAuth();

// Initialize navigation
document.addEventListener('DOMContentLoaded', function() {
    const sidebar = document.querySelector('.sidebar-nav');
    if (sidebar && isAuthenticated()) {
        sidebar.innerHTML = generateNavigation();
    }
});

// Notification system
function showNotification(message, type = 'info') {
    const notification = document.createElement('div');
    notification.className = `notification notification-${type}`;
    notification.textContent = message;
    
    notification.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        padding: 16px 24px;
        background: ${type === 'success' ? 'var(--secondary)' : type === 'error' ? '#ff6b6b' : 'var(--primary)'};
        color: white;
        border-radius: 8px;
        box-shadow: 0 4px 20px var(--shadow);
        z-index: 1001;
        animation: slideIn 0.3s ease-out;
    `;
    
    document.body.appendChild(notification);
    
    setTimeout(() => {
        notification.style.animation = 'slideOut 0.3s ease-out';
        setTimeout(() => {
            document.body.removeChild(notification);
        }, 300);
    }, 3000);
}

// AgriLane Map instance
let agriMap;

function initMap() {
    agriMap = new AgriLaneMap('map', {
        center: [20.5937, 78.9629],
        zoom: 6
    });
}

async function calculateOptimalRoute(start, destinations) {
    if (!agriMap) return;
    
    showNotification('Calculating route using OpenRouteService API...', 'info');
    
    try {
        // Use OpenRouteService API for accurate routing
        let totalDistance = 0;
        let totalTime = 0;
        const waypoints = [];
        const popups = [`Start: ${start}`];
        
        // Get starting coordinates
        const startCoords = agriMap.getCityCoords(start);
        waypoints.push(startCoords);
        
        // Calculate route through all destinations using API
        for (let i = 0; i < destinations.length; i++) {
            const fromCoords = i === 0 ? startCoords : agriMap.getCityCoords(destinations[i-1]);
            const toCoords = agriMap.getCityCoords(destinations[i]);
            
            const routeData = await agriMap.calculateRoute(fromCoords, toCoords);
            
            if (routeData) {
                totalDistance += routeData.distance;
                totalTime += routeData.duration;
            }
            
            waypoints.push(toCoords);
            popups.push(`Stop ${i + 1}: ${destinations[i]}`);
        }
        
        updateRouteInfo(totalDistance, totalTime, start, destinations);
        showRouteOnMap(waypoints, popups);
        
        showNotification('Route optimized using API data!', 'success');
    } catch (error) {
        console.error('Route calculation failed:', error);
        showNotification('API failed, using fallback calculation', 'error');
        
        // Fallback to basic calculation
        const startCoords = agriMap.getCityCoords(start);
        const waypoints = [startCoords];
        const popups = [`Start: ${start}`];
        
        for (let i = 0; i < destinations.length; i++) {
            const coords = agriMap.getCityCoords(destinations[i]);
            waypoints.push(coords);
            popups.push(`Stop ${i + 1}: ${destinations[i]}`);
        }
        
        let totalDistance = 0;
        for (let i = 0; i < waypoints.length - 1; i++) {
            totalDistance += agriMap.calculateDistance(waypoints[i], waypoints[i + 1]);
        }
        
        const totalTime = Math.round(totalDistance * 1.5);
        
        updateRouteInfo(totalDistance, totalTime, start, destinations);
        showRouteOnMap(waypoints, popups);
    }
}

function showRouteOnMap(waypoints, popups) {
    if (!agriMap) return;
    
    // Create route with waypoints
    agriMap.createRoute(waypoints, { popups });
}

function updateRouteInfo(distance, time, start, destinations) {
    const cost = Math.round(distance * 8);
    const vehicle = document.getElementById('vehicleType').value;
    
    // Store current route data
    currentRoute = {
        start,
        destinations,
        distance,
        time,
        cost,
        vehicle,
        startCoords: agriMap.getCityCoords(start),
        waypoints: destinations.map(dest => ({
            ...agriMap.getCityCoords(dest),
            name: dest
        }))
    };
    
    const routeOptionsHtml = `
        <div class="route-option">
            <div class="route-header">
                <h4>üöõ API-Optimized Route</h4>
                <span class="route-distance">${distance} km</span>
            </div>
            <p><strong>‚è±Ô∏è Estimated Time:</strong> ${time} minutes</p>
            <p><strong>‚õΩ Fuel Cost:</strong> ‚Çπ${cost}</p>
            <p><strong>üöö Vehicle:</strong> ${vehicle}</p>
            <p><strong>üó∫Ô∏è Route:</strong> ${start} ‚Üí ${destinations.join(' ‚Üí ')}</p>
            <p><small>‚úÖ Calculated using OpenRouteService API</small></p>
            <button class="btn btn-primary" onclick="selectRoute()">Select Route</button>
        </div>
    `;
    
    document.getElementById('routeOptionsList').innerHTML = routeOptionsHtml;
}
    </script>
    <script>
        async function loadFarmsIntoDropdown() {
            try {
                const response = await fetch('http://localhost:5000/api/farms');
                const farms = await response.json();
                
                const dropdown = document.getElementById('startingFarm');
                dropdown.innerHTML = '<option value="">Select Farm</option>';
                
                farms.forEach(farm => {
                    dropdown.innerHTML += `<option value="${farm.name}">${farm.name} - ${farm.location}</option>`;
                });
            } catch (error) {
                console.error('Error loading farms:', error);
            }
        }
        
        async function calculateRoute() {
            const start = document.getElementById('startingFarm').value;
            const destinations = document.getElementById('deliveryLocations').value.split('\n').filter(d => d.trim());
            
            if (!start || destinations.length === 0) {
                showNotification('Please select a starting farm and add delivery locations', 'error');
                return;
            }
            
            await calculateOptimalRoute(start, destinations);
        }
        
        function generateOptimalRoute() {
            calculateRoute();
        }
        
        function exportToPDF() {
            const routeData = getCurrentRouteData();
            if (!routeData) {
                showNotification('Please calculate a route first', 'error');
                return;
            }
            
            // Create PDF content
            const pdfContent = `
AgriLane Route Plan
==================
From: ${routeData.start}
To: ${routeData.destinations.join(', ')}
Distance: ${routeData.distance} km
Estimated Time: ${routeData.time} minutes
Fuel Cost: ‚Çπ${routeData.cost}
Vehicle: ${routeData.vehicle}
            `;
            
            // Create and download PDF-like text file
            const blob = new Blob([pdfContent], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'agrilane-route-plan.txt';
            a.click();
            URL.revokeObjectURL(url);
            
            showNotification('Route plan downloaded!', 'success');
        }
        

        function shareRoute() {
            const routeData = getCurrentRouteData();
            if (!routeData) {
                showNotification('Please calculate a route first', 'error');
                return;
            }
            
            const shareText = `AgriLane Route: ${routeData.start} ‚Üí ${routeData.destinations.join(' ‚Üí ')} (${routeData.distance}km, ${routeData.time}min, ‚Çπ${routeData.cost})`;
            
            if (navigator.share) {
                navigator.share({
                    title: 'AgriLane Route Plan',
                    text: shareText
                });
            } else {
                navigator.clipboard.writeText(shareText).then(() => {
                    showNotification('Route copied to clipboard!', 'success');
                }).catch(() => {
                    showNotification('Unable to copy route', 'error');
                });
            }
        }
        
        let currentRoute = null;
        
        function getCurrentRouteData() {
            return currentRoute;
        }
        
        async function selectRoute() {
            if (!currentRoute) return;
            
            const user = getCurrentUser();
            const routeData = {
                name: `${currentRoute.start} to ${currentRoute.destinations.join(', ')}`,
                startLocation: {
                    name: currentRoute.start,
                    coordinates: currentRoute.startCoords
                },
                waypoints: currentRoute.waypoints,
                distance: currentRoute.distance,
                estimatedTime: currentRoute.time,
                cost: currentRoute.cost
            };
            
            try {
                const response = await fetch('http://localhost:5000/api/routes', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(routeData)
                });
                
                if (response.ok) {
                    showNotification('Route saved to database!', 'success');
                } else {
                    showNotification('Failed to save route', 'error');
                }
            } catch (error) {
                showNotification('Connection error', 'error');
            }
        }
        
        // Load farms when page loads
        document.addEventListener('DOMContentLoaded', function() {
            loadFarmsIntoDropdown();
            setTimeout(initMap, 100);
        });
    </script>
</body>
</html>